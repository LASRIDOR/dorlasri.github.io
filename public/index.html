<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta name="theme-color" content="#000000" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/brands.css" integrity="sha384-n9+6/aSqa9lBidZMRCQHTHKJscPq6NW4pCQBiMmHdUCvPN8ZOg2zJJTkC7WIezWv" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.1/css/fontawesome.css" integrity="sha384-vd1e11sR28tEK9YANUtpIOdjGW14pS87bUBuOIoBILVWLFnS+MCX9T6MMf0VdPGq" crossorigin="anonymous">
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Aaron Osher</title>
    <style>
      #scene {
        position: fixed;
        height: 100vh;
        width: 100vw;
        max-width: 100%;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="scene"></div>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
  <!-- <script>
    var container = document.getElementById('scene');
    var renderer = new FSS.CanvasRenderer();
    var scene = new FSS.Scene();
    var light = new FSS.Light('#4d4d4d', '#555555');
    var geometry = new FSS.Plane(screen.availWidth, screen.availHeight, 16, 8);
    var material = new FSS.Material('#555555', '#FFFFFF');
    var mesh = new FSS.Mesh(geometry, material);
    var now, start = Date.now();
    var lightBounds = FSS.Vector3.create();

    var v, vertex;
    for (v = geometry.vertices.length - 1; v >= 0; v--) {
      vertex = geometry.vertices[v];
      vertex.anchor = FSS.Vector3.clone(vertex.position);
      vertex.step = FSS.Vector3.create(
        Math.randomInRange(0.2, 1.0),
        Math.randomInRange(0.2, 1.0),
        Math.randomInRange(0.2, 1.0)
      );
      vertex.time = Math.randomInRange(0, Math.PIM2);
    }

    function initialise() {
      scene.add(mesh);
      scene.add(light);
      container.appendChild(renderer.element);
      window.addEventListener('resize', resize);
    }
    function resize() {
      renderer.setSize(screen.availWidth, container.offsetHeight);
    }
    function animate() {
      now = Date.now() - start;
      light.setPosition(300*Math.sin(now*0.001), 200*Math.cos(now*0.0005), 60);
      renderer.render(scene);
      requestAnimationFrame(animate);
    }
    function update() {
      var ox, oy, oz, l, light, v, vertex, offset = 5;

      // Animate Vertices
      for (v = geometry.vertices.length - 1; v >= 0; v--) {
        vertex = geometry.vertices[v];
        ox = Math.sin(vertex.time + vertex.step[0] * now * 0.0007);
        oy = Math.cos(vertex.time + vertex.step[1] * now * 0.0007);
        oz = Math.sin(vertex.time + vertex.step[2] * now * 0.0007);
        FSS.Vector3.set(vertex.position,
          0.8*geometry.segmentWidth*ox,
          0.1*geometry.sliceHeight*oy,
          1.0*offset*oz - offset);
        FSS.Vector3.add(vertex.position, vertex.anchor);
      }

      // Set the Geometry to dirty
      geometry.dirty = true;
    }
    initialise();
    resize();
    animate();
  </script> -->
  <script>
    (function(){

      //------------------------------
      // Mesh Properties
      //------------------------------
      var MESH = {
        width: 1.2,
        height: 1.2,
        depth: 10,
        segments: 16,
        slices: 8,
        xRange: 0.8,
        yRange: 0.1,
        zRange: 1.0,
        ambient: '#4d4d4d',
        diffuse: '#555555',
        speed: 0.0007
      };

      //------------------------------
      // Light Properties
      //------------------------------
      var LIGHT = {
        count: 1,
        xyScalar: 1,
        zOffset: 200,
        ambient: '#4d4d4d',
        diffuse: '#555555',
        speed: 100,
        gravity: 0,
        dampening: 0.95,
        minLimit: 10,
        maxLimit: null,
        minDistance: 20,
        maxDistance: 400,
        autopilot: true,
        draw: false,
        bounds: FSS.Vector3.create(),
        step: FSS.Vector3.create(
          Math.randomInRange(0.2, 1.0),
          Math.randomInRange(0.2, 1.0),
          Math.randomInRange(0.2, 1.0)
        )
      };

      //------------------------------
      // Render Properties
      //------------------------------
      var CANVAS = 'canvas';
      var RENDER = {
        renderer: CANVAS
      };

      //------------------------------
      // Export Properties
      //------------------------------
      var EXPORT = {
        width: 2000,
        height: 1000,
        drawLights: false,
        minLightX: 0.4,
        maxLightX: 0.6,
        minLightY: 0.2,
        maxLightY: 0.4,
        export: function() {
          var l, x, y, light,
              depth = MESH.depth,
              zOffset = LIGHT.zOffset,
              autopilot = LIGHT.autopilot,
              scalar = this.width / renderer.width;

          LIGHT.autopilot = true;
          LIGHT.draw = this.drawLights;
          LIGHT.zOffset *= scalar;
          MESH.depth *= scalar;

          resize(this.width, this.height);

          for (l = scene.lights.length - 1; l >= 0; l--) {
            light = scene.lights[l];
            x = Math.randomInRange(this.width*this.minLightX, this.width*this.maxLightX);
            y = Math.randomInRange(this.height*this.minLightY, this.height*this.maxLightY);
            FSS.Vector3.set(light.position, x, this.height-y, this.lightZ);
            FSS.Vector3.subtract(light.position, center);
          }

          update();
          render();

          switch(RENDER.renderer) {
            case CANVAS:
              window.open(canvasRenderer.element.toDataURL(), '_blank');
              break;
          }

          LIGHT.draw = true;
          LIGHT.autopilot = autopilot;
          LIGHT.zOffset = zOffset;
          MESH.depth = depth;

          resize(container.offsetWidth, container.offsetHeight);
        }
      };

      //------------------------------
      // UI Properties
      //------------------------------
      var UI = {
        show: true
      };

      //------------------------------
      // Global Properties
      //------------------------------
      var now, start = Date.now();
      var center = FSS.Vector3.create();
      var attractor = FSS.Vector3.create();
      var container = document.getElementById('scene');
      var output = document.getElementById('scene');
      var renderer, scene, mesh, geometry, material;
      var canvasRenderer;
      var gui, autopilotController;

      //------------------------------
      // Methods
      //------------------------------
      function initialise() {
        createRenderer();
        createScene();
        createMesh();
        createLights();
        addEventListeners();
        resize(container.offsetWidth, container.offsetHeight);
        animate();
      }

      function createRenderer() {
        canvasRenderer = new FSS.CanvasRenderer();
        setRenderer(RENDER.renderer);
      }

      function setRenderer(index) {
        if (renderer) {
          output.removeChild(renderer.element);
        }
        switch(index) {
          case CANVAS:
            renderer = canvasRenderer;
            break;
        }
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        output.appendChild(renderer.element);
      }

      function createScene() {
        scene = new FSS.Scene();
      }

      function createMesh() {
        scene.remove(mesh);
        renderer.clear();
        geometry = new FSS.Plane(MESH.width * renderer.width, MESH.height * renderer.height, MESH.segments, MESH.slices);
        material = new FSS.Material(MESH.ambient, MESH.diffuse);
        mesh = new FSS.Mesh(geometry, material);
        scene.add(mesh);

        // Augment vertices for animation
        var v, vertex;
        for (v = geometry.vertices.length - 1; v >= 0; v--) {
          vertex = geometry.vertices[v];
          vertex.anchor = FSS.Vector3.clone(vertex.position);
          vertex.step = FSS.Vector3.create(
            Math.randomInRange(0.2, 1.0),
            Math.randomInRange(0.2, 1.0),
            Math.randomInRange(0.2, 1.0)
          );
          vertex.time = Math.randomInRange(0, Math.PIM2);
        }
      }

      function createLights() {
        var l, light;
        for (l = scene.lights.length - 1; l >= 0; l--) {
          light = scene.lights[l];
          scene.remove(light);
        }
        renderer.clear();
        for (l = 0; l < LIGHT.count; l++) {
          light = new FSS.Light(LIGHT.ambient, LIGHT.diffuse);
          light.ambientHex = light.ambient.format();
          light.diffuseHex = light.diffuse.format();
          scene.add(light);

          // Augment light for animation
          light.mass = Math.randomInRange(0.5, 1);
          light.velocity = FSS.Vector3.create();
          light.acceleration = FSS.Vector3.create();
          light.force = FSS.Vector3.create();

          // Ring SVG Circle
          light.ring = document.createElementNS(FSS.SVGNS, 'circle');
          light.ring.setAttributeNS(null, 'stroke', light.ambientHex);
          light.ring.setAttributeNS(null, 'stroke-width', '0.5');
          light.ring.setAttributeNS(null, 'fill', 'none');
          light.ring.setAttributeNS(null, 'r', '10');

          // Core SVG Circle
          light.core = document.createElementNS(FSS.SVGNS, 'circle');
          light.core.setAttributeNS(null, 'fill', light.diffuseHex);
          light.core.setAttributeNS(null, 'r', '4');
        }
      }

      function resize(width, height) {
        renderer.setSize(width, height);
        FSS.Vector3.set(center, renderer.halfWidth, renderer.halfHeight);
        createMesh();
      }

      function animate() {
        now = Date.now() - start;
        update();
        render();
        requestAnimationFrame(animate);
      }

      function update() {
        var ox, oy, oz, l, light, v, vertex, offset = MESH.depth/2;

        // Update Bounds
        FSS.Vector3.copy(LIGHT.bounds, center);
        FSS.Vector3.multiplyScalar(LIGHT.bounds, LIGHT.xyScalar);

        // Update Attractor
        FSS.Vector3.setZ(attractor, LIGHT.zOffset);

        // Overwrite the Attractor position
        if (LIGHT.autopilot) {
          ox = Math.sin(LIGHT.step[0] * now * LIGHT.speed);
          oy = Math.cos(LIGHT.step[1] * now * LIGHT.speed);
          FSS.Vector3.set(attractor,
            LIGHT.bounds[0]*ox,
            LIGHT.bounds[1]*oy,
            LIGHT.zOffset);
        }

        // Animate Lights
        for (l = scene.lights.length - 1; l >= 0; l--) {
          light = scene.lights[l];

          // Reset the z position of the light
          FSS.Vector3.setZ(light.position, LIGHT.zOffset);

          // Calculate the force Luke!
          var D = Math.clamp(FSS.Vector3.distanceSquared(light.position, attractor), LIGHT.minDistance, LIGHT.maxDistance);
          var F = LIGHT.gravity * light.mass / D;
          FSS.Vector3.subtractVectors(light.force, attractor, light.position);
          FSS.Vector3.normalise(light.force);
          FSS.Vector3.multiplyScalar(light.force, F);

          // Update the light position
          FSS.Vector3.set(light.acceleration);
          FSS.Vector3.add(light.acceleration, light.force);
          FSS.Vector3.add(light.velocity, light.acceleration);
          FSS.Vector3.multiplyScalar(light.velocity, LIGHT.dampening);
          FSS.Vector3.limit(light.velocity, LIGHT.minLimit, LIGHT.maxLimit);
          FSS.Vector3.add(light.position, light.velocity);
        }

        // Animate Vertices
        for (v = geometry.vertices.length - 1; v >= 0; v--) {
          vertex = geometry.vertices[v];
          ox = Math.sin(vertex.time + vertex.step[0] * now * MESH.speed);
          oy = Math.cos(vertex.time + vertex.step[1] * now * MESH.speed);
          oz = Math.sin(vertex.time + vertex.step[2] * now * MESH.speed);
          FSS.Vector3.set(vertex.position,
            MESH.xRange*geometry.segmentWidth*ox,
            MESH.yRange*geometry.sliceHeight*oy,
            MESH.zRange*offset*oz - offset);
          FSS.Vector3.add(vertex.position, vertex.anchor);
        }

        // Set the Geometry to dirty
        geometry.dirty = true;
      }

      function render() {
        renderer.render(scene);

        // Draw Lights
        if (LIGHT.draw) {
          var l, lx, ly, light;
          for (l = scene.lights.length - 1; l >= 0; l--) {
            light = scene.lights[l];
            lx = light.position[0];
            ly = light.position[1];
            switch(RENDER.renderer) {
              case CANVAS:
                renderer.context.lineWidth = 0.5;
                renderer.context.beginPath();
                renderer.context.arc(lx, ly, 10, 0, Math.PIM2);
                renderer.context.strokeStyle = light.ambientHex;
                renderer.context.stroke();
                renderer.context.beginPath();
                renderer.context.arc(lx, ly, 4, 0, Math.PIM2);
                renderer.context.fillStyle = light.diffuseHex;
                renderer.context.fill();
                break;
            }
          }
        }
      }

      function addEventListeners() {
        window.addEventListener('resize', onWindowResize);
        container.addEventListener('click', onMouseClick);
        container.addEventListener('mousemove', onMouseMove);
      }

      //------------------------------
      // Callbacks
      //------------------------------
      function onMouseClick(event) {
        FSS.Vector3.set(attractor, event.x, renderer.height - event.y);
        FSS.Vector3.subtract(attractor, center);
        LIGHT.autopilot = !LIGHT.autopilot;
        autopilotController.updateDisplay();
      }

      function onMouseMove(event) {
        FSS.Vector3.set(attractor, event.x, renderer.height - event.y);
        FSS.Vector3.subtract(attractor, center);
      }

      function onWindowResize(event) {
        resize(container.offsetWidth, container.offsetHeight);
        render();
      }



      // Let there be light!
      initialise();

      })();
  </script>
</html>
